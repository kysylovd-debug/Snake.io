<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Tetris</title>
    <style>
        :root {
            --game-height: 800px;
        }
        body {
            background-color: #1a1a1a;
            color: #fff;
            font-family: 'Courier New', Courier, monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start; /* Aligne en haut */
            min-height: 100vh;
            margin: 0;
            padding: 20px 0;
            box-sizing: border-box;
        }
        h1 { font-size: 3em; margin-bottom: 20px; text-align: center; }

        .page-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }
        .game-column {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .game-wrapper {
            position: relative;
            width: calc(var(--game-height) / 2);
            height: var(--game-height);
            max-width: 45vh; /* Ratio 1:2 */
            max-height: 75vh; /* Hauteur réduite pour mobile */
        }
        canvas {
            width: 100%;
            height: 100%;
            border: 2px solid #555;
            cursor: pointer;
        }
        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 20px;
            width: 220px;
        }
        .info-box {
            background-color: #2a2a2a;
            padding: 10px;
            border-radius: 8px;
            border: 2px solid #555;
            text-align: center;
        }
        .info-box p { margin: 5px 0; font-size: 1.2em; }
        .info-box span { font-size: 1.5em; color: #AED542; }
        
        .controls {
            text-align: center;
            width: 220px;
        }
        .slider-container { margin-top: 10px; }
        .slider-labels { display: flex; justify-content: space-between; font-size: 0.8em; padding: 0 5px; }
        input[type="range"] {
            -webkit-appearance: none; appearance: none;
            width: 100%; height: 15px; background: #555;
            border-radius: 5px; outline: none; opacity: 0.7;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none;
            width: 25px; height: 25px; background: #008CBA;
            border: 2px solid white; border-radius: 50%; cursor: pointer;
        }
        #replayButton {
            display: none; position: absolute;
            top: 60%; left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10; padding: 15px 30px;
            font-size: 1.5em; font-family: 'Courier New', Courier, monospace;
            color: white; background-color: #008CBA;
            border: 3px solid white; border-radius: 8px; cursor: pointer;
        }
        #touch-controls {
            display: none;
            margin-top: 20px;
            width: 210px;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(2, 60px);
            gap: 15px;
        }
        .touch-btn {
            background-color: rgba(255, 255, 255, 0.7);
            border-radius: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5em;
            color: #1a1a1a;
            user-select: none;
            width: 60px;
            height: 60px;
        }
        #touch-left { grid-area: 2 / 1 / 3 / 2; font-size: 2em; }
        #touch-down { grid-area: 2 / 2 / 3 / 3; font-size: 2em; }
        #touch-right { grid-area: 2 / 3 / 3 / 4; font-size: 2em; }
        #touch-rotate-left { grid-area: 1 / 1 / 2 / 2; font-size: 2em; }
        #touch-drop { grid-area: 1 / 2 / 2 / 3; }
        #touch-rotate-right { grid-area: 1 / 3 / 2 / 4; font-size: 2em; }
        

        @media (min-width: 700px) {
            .page-content {
                flex-direction: row;
                align-items: center;
                gap: 20px;
            }
            .sidebar {
                order: 2;
            }
            .game-column {
                order: 1;
            }
        }
    </style>
</head>
<body>
    <div class="page-content">
        <div class="game-column">
            <h1>TETRIS</h1>
            <div class="game-wrapper" id="game-wrapper">
                <canvas id="gameCanvas"></canvas>
                <button id="replayButton">Rejouer</button>
            </div>
             <div id="touch-controls">
                <div id="touch-drop" class="touch-btn">DROP</div>
                <div id="touch-rotate-left" class="touch-btn">↺</div>
                <div id="touch-rotate-right" class="touch-btn">↻</div>
                <div id="touch-left" class="touch-btn">←</div>
                <div id="touch-down" class="touch-btn">↓</div>
                <div id="touch-right" class="touch-btn">→</div>
            </div>
             <p class="keyboard-instructions" style="font-size: 0.9em; margin-top: 15px;">Clavier : ← → ↓, Espace (Drop) | Souris: Clic G/D (Pivoter)</p>
        </div>
        <div class="sidebar">
            <div class="info-box">
                <p>SCORE</p>
                <span id="current-score">0</span>
            </div>
            <div class="info-box">
                <p>BEST SCORE</p>
                <span id="high-score">0</span>
            </div>
            <div class="controls">
                <div class="slider-container">
                    <p>VITESSE</p>
                    <div class="slider-labels">
                        <span>1</span><span>2</span><span>3</span><span>4</span><span>5</span><span>6</span><span>7</span><span>8</span><span>9</span><span>10</span>
                    </div>
                    <input type="range" id="speedSlider" min="1" max="10" value="1">
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const currentScoreElement = document.getElementById('current-score');
        const highScoreElement = document.getElementById('high-score');
        const speedSlider = document.getElementById('speedSlider');
        const replayButton = document.getElementById('replayButton');

        const COLS = 11; const ROWS = 20; let blockSize;

        const COLORS = [ null, '#33C7DE', '#2A64D9', '#E6994C', '#E6D84C', '#6AE64C', '#A94CE6', '#E64C4C' ];
        const SHAPES = [ [], [[1,1,1,1]], [[2,0,0],[2,2,2]], [[0,0,3],[3,3,3]], [[4,4],[4,4]], [[0,5,5],[5,5,0]], [[0,6,0],[6,6,6]], [[7,7,0],[0,7,7]] ];

        let playfield = [];
        let player = { piece: null, x: 0, y: 0 };
        let nextPiece = null;
        let score = 0; let highScore = 0; let level = 1;
        let dropCounter = 0; let dropInterval = 1000;
        let lastTime = 0; let gameState = 'START';
        let countdownActive = false; let animationFrameId;

        function resizeGame() {
            const wrapper = document.getElementById('game-wrapper');
            const h = wrapper.clientHeight;
            const w = h * (COLS / ROWS);
            canvas.height = h; canvas.width = w;
            blockSize = h / ROWS;
            draw();
        }

        function createPlayfield() { return Array.from({ length: ROWS }, () => Array(COLS).fill(0)); }
        function createPiece() { return SHAPES[Math.floor(Math.random() * (SHAPES.length - 1)) + 1]; }

        function isValidMove(piece, offsetX, offsetY) {
            for (let y = 0; y < piece.length; y++) {
                for (let x = 0; x < piece[y].length; x++) {
                    if (piece[y][x] !== 0) {
                        const newX = player.x + x + offsetX;
                        const newY = player.y + y + offsetY;
                        if (newX < 0 || newX >= COLS || newY >= ROWS || (playfield[newY] && playfield[newY][newX] !== 0)) return false;
                    }
                }
            }
            return true;
        }

        function rotate(matrix, dir) {
            const M = matrix.length; const N = matrix[0].length;
            const result = Array.from({ length: N }, () => Array(M).fill(0));
            for (let i = 0; i < N; i++) {
                for (let j = 0; j < M; j++) {
                    if (dir > 0) result[i][j] = matrix[M - 1 - j][i];
                    else result[i][j] = matrix[j][N - 1 - i];
                }
            }
            return result;
        }
        
        function playerRotate(dir) {
            const originalPiece = player.piece;
            const originalX = player.x;
            const rotated = rotate(player.piece, dir);
            player.piece = rotated;

            let offset = 1;
            if (isValidMove(player.piece, 0, 0)) return;
            player.x += offset;
            if (isValidMove(player.piece, 0, 0)) return;
            player.x -= offset * 2;
            if (isValidMove(player.piece, 0, 0)) return;
            
            player.x = originalX;
            player.piece = originalPiece;
        }

        function placePiece() {
            player.piece.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) { playfield[player.y + y][player.x + x] = value; }
                });
            });
        }

        function clearLines() {
            let linesCleared = 0;
            outer: for (let y = ROWS - 1; y >= 0; y--) {
                for (let x = 0; x < COLS; x++) { if (playfield[y][x] === 0) continue outer; }
                playfield.splice(y, 1);
                linesCleared++;
            }
            if (linesCleared > 0) {
                while(playfield.length < ROWS) playfield.unshift(Array(COLS).fill(0));
                score += linesCleared * 10 * linesCleared;
                level = Math.floor(score / 100) + parseInt(speedSlider.value);
                dropInterval = 1000 / (level * 1.5);
            }
        }
        
        function playerDrop() {
            if (isValidMove(player.piece, 0, 1)) {
                player.y++;
            } else {
                placePiece();
                clearLines();
                playerReset();
                if (!isValidMove(player.piece, 0, 0)) {
                    gameState = 'GAME_OVER';
                    replayButton.style.display = 'block';
                    if (score > highScore) {
                        highScore = score;
                        localStorage.setItem('tetrisHighScore', highScore);
                    }
                }
            }
            dropCounter = 0;
        }
        
        function playerMove(offset) { if (isValidMove(player.piece, offset, 0)) player.x += offset; }
        function playerReset() {
            player.piece = nextPiece;
            player.x = Math.floor(COLS / 2) - Math.floor(player.piece[0].length / 2);
            player.y = 0;
            nextPiece = createPiece();
        }
        
        function update(time = 0) {
            const deltaTime = time - lastTime;
            lastTime = time;
            dropCounter += deltaTime;

            if (!isValidMove(player.piece, 0, 1)) {
                 placePiece();
                 clearLines();
                 playerReset();
                 if (!isValidMove(player.piece, 0, 0)) gameState = 'GAME_OVER';
            } else {
                if (dropCounter > dropInterval) {
                    player.y++;
                    dropCounter = 0;
                }
            }
        }

        function lightenColor(hex, percent) {
            let r = parseInt(hex.slice(1, 3), 16), g = parseInt(hex.slice(3, 5), 16), b = parseInt(hex.slice(5, 7), 16);
            r = Math.min(255, Math.floor(r * (1 + percent / 100)));
            g = Math.min(255, Math.floor(g * (1 + percent / 100)));
            b = Math.min(255, Math.floor(b * (1 + percent / 100)));
            return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
        }

        function drawPiece(matrix, offset, context, pieceSize) {
            matrix.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) {
                        const mainColor = COLORS[value];
                        const lightColor = lightenColor(mainColor, 25);
                        const inset = pieceSize * 0.1;
                        const posX = (offset.x + x) * pieceSize;
                        const posY = (offset.y + y) * pieceSize;
                        
                        context.fillStyle = mainColor;
                        context.fillRect(posX, posY, pieceSize, pieceSize);
                        
                        context.fillStyle = lightColor;
                        context.fillRect(posX + inset, posY + inset, pieceSize - inset * 2, pieceSize - inset * 2);
                    }
                });
            });
        }
        
        function drawGrid() {
            ctx.strokeStyle = '#303030';
            ctx.lineWidth = 1;
            for (let i = 1; i < COLS; i++) {
                ctx.beginPath(); ctx.moveTo(i * blockSize, 0); ctx.lineTo(i * blockSize, canvas.height); ctx.stroke();
            }
            for (let i = 1; i < ROWS; i++) {
                ctx.beginPath(); ctx.moveTo(0, i * blockSize); ctx.lineTo(canvas.width, i * blockSize); ctx.stroke();
            }
        }

        function draw() {
            ctx.fillStyle = '#1C1C1C';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            drawGrid();
            drawPiece(playfield, {x: 0, y: 0}, ctx, blockSize);
            
            if (gameState === 'PLAYING') {
                drawPiece(player.piece, player, ctx, blockSize);
                if(nextPiece) {
                    ctx.globalAlpha = 0.3;
                    drawPiece(nextPiece, {x: COLS - 4, y: 1}, ctx, blockSize * 0.8);
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                    ctx.font = `${blockSize * 0.8}px "Courier New"`;
                    ctx.textAlign = 'center';
                    ctx.fillText('NEXT', (COLS - 2) * blockSize, 1 * blockSize);
                    ctx.globalAlpha = 1.0;
                }
            }
            currentScoreElement.textContent = score;
            highScoreElement.textContent = highScore;
        }
        
        function gameLoop(time) {
            if(gameState === 'PLAYING' && !countdownActive) update(time);
            draw();
            animationFrameId = requestAnimationFrame(gameLoop);
        }
        
        function startGame() {
            if(gameState === 'PLAYING' && !countdownActive) return;
            gameState = 'PLAYING';
            playfield = createPlayfield();
            score = 0;
            level = parseInt(speedSlider.value);
            dropInterval = 1000 / level;
            nextPiece = createPiece();
            playerReset();
            replayButton.style.display = 'none';
            
            countdownActive = true;
            let countdown = 3;
            const countdownInterval = setInterval(() => {
                draw();
                if (countdown > 0) {
                    ctx.fillStyle = 'rgba(0,0,0,0.7)';
                    ctx.fillRect(0,0,canvas.width, canvas.height);
                    ctx.fillStyle = 'white';
                    ctx.font = `${blockSize * 4}px "Courier New"`;
                    ctx.textAlign = 'center';
                    ctx.fillText(countdown, canvas.width / 2, canvas.height / 2);
                    countdown--;
                } else {
                    clearInterval(countdownInterval);
                    countdownActive = false;
                    lastTime = performance.now();
                    if(!animationFrameId) gameLoop();
                }
            }, 1000);
        }

        function handleKeyPress(e) {
            if (gameState === 'START' || gameState === 'GAME_OVER') {
                if (e.key === 'Enter') startGame();
                return;
            }
            if (gameState !== 'PLAYING' || countdownActive) return;
            e.preventDefault();

            if (e.key === 'ArrowLeft') playerMove(-1);
            else if (e.key === 'ArrowRight') playerMove(1);
            else if (e.key === 'ArrowDown') playerDrop();
            else if (e.key === ' ') { 
                while(isValidMove(player.piece, 0, 1)) { player.y++; }
                playerDrop();
            }
        }
        
        function handleMouseClick(e) {
            if (gameState !== 'PLAYING' || countdownActive) return;
            e.preventDefault();
            if (e.button === 0) playerRotate(-1);
            if (e.button === 2) playerRotate(1);
        }
        
        function setupTouchControls() {
            const isTouch = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
            const instructions = document.querySelector('.keyboard-instructions');
            
            if(!isTouch) {
                document.getElementById('touch-controls').style.display = 'none';
                if(instructions) instructions.style.display = 'block';
                return;
            }
            
            document.getElementById('touch-controls').style.display = 'grid';
            if(instructions) instructions.style.display = 'none';
            
            const handleTouch = (e, action) => {
                e.preventDefault();
                if (gameState === 'START' || gameState === 'GAME_OVER') { startGame(); return; }
                if (gameState !== 'PLAYING' || countdownActive) return;
                switch(action) {
                    case 'left': playerMove(-1); break;
                    case 'right': playerMove(1); break;
                    case 'down': playerDrop(); break;
                    case 'rotate-right': playerRotate(1); break;
                    case 'rotate-left': playerRotate(-1); break;
                    case 'drop': while(isValidMove(player.piece, 0, 1)) { player.y++; } playerDrop(); break;
                }
            };
            
            document.getElementById('touch-left').addEventListener('click', (e) => handleTouch(e, 'left'));
            document.getElementById('touch-right').addEventListener('click', (e) => handleTouch(e, 'right'));
            document.getElementById('touch-down').addEventListener('click', (e) => handleTouch(e, 'down'));
            document.getElementById('touch-rotate-right').addEventListener('click', (e) => handleTouch(e, 'rotate-right'));
            document.getElementById('touch-rotate-left').addEventListener('click', (e) => handleTouch(e, 'rotate-left'));
            document.getElementById('touch-drop').addEventListener('click', (e) => handleTouch(e, 'drop'));
        }
        
        function setupSliderTouch() { /* ... */ }
        replayButton.addEventListener('click', startGame);
        
        function drawStartScreen() {
            gameState = 'START';
            draw();
            ctx.fillStyle = 'rgba(0,0,0,0.7)';
            ctx.fillRect(0,0,canvas.width, canvas.height);
            ctx.fillStyle = 'white';
            ctx.font = `${blockSize * 1.3}px "Courier New"`;
            ctx.textAlign = 'center';
            const textLines = ["Appuyez sur", "Entrée", "ou touchez", "l'écran"];
            textLines.forEach((line, index) => {
                ctx.fillText(line, canvas.width / 2, canvas.height / 2 - (blockSize * (textLines.length / 2 - index - 0.5) * 1.5) );
            });
        }
        
        window.addEventListener('DOMContentLoaded', () => {
            highScore = localStorage.getItem('tetrisHighScore') || 0;
            resizeGame();
            drawStartScreen();
            setupTouchControls();
            setupSliderTouch();
            canvas.addEventListener('click', (e) => {
                if(e.button !== 0) return;
                if (gameState === 'START' || gameState === 'GAME_OVER') startGame();
            });
            canvas.addEventListener('mousedown', handleMouseClick);
            canvas.addEventListener('contextmenu', e => e.preventDefault());
        });

        window.addEventListener('resize', resizeGame);
        document.addEventListener('keydown', handleKeyPress);
    </script>
</body>
</html>
